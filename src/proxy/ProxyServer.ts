import * as http from 'http';
import httpProxy from 'http-proxy';
import * as vscode from 'vscode';
import * as zlib from 'zlib';
import * as fs from 'fs';
import * as path from 'path';
import * as crypto from 'crypto';

// @ts-ignore
const chii = require('chii');

export class ProxyServer {
    private _proxy: httpProxy;
    private _server: http.Server | undefined;
    private _extensionUri: vscode.Uri;
    private _port: number = 0;
    private _extensionHostPort: number = 0;
    private _injectedScript: string = '';
    private _chiiPort: number | undefined;
    private _chiiServer: http.Server | undefined;
    private _chiiReady: boolean = false;
    private _chiiStartupError: Error | undefined;

    private _chiiServerPromise: Promise<void> | undefined;

    constructor(extensionUri: vscode.Uri) {
        this._extensionUri = extensionUri;
        
        // Load the injected script content once (now generated by webpack from TypeScript)
        try {
            const scriptPath = path.join(this._extensionUri.fsPath, 'media', 'injected-picker.js');
            this._injectedScript = fs.readFileSync(scriptPath, 'utf8');
        } catch (e) {
            console.error('Failed to load injected-picker.js (ensure webview-ui has been built):', e);
        }

        this._proxy = httpProxy.createProxyServer({
            ws: true,
            xfwd: true,
            secure: false,
            changeOrigin: false,
            selfHandleResponse: true // IMPORTANT: Allows us to modify response
        });

        // Pre-start Chii server and store the promise
        this._chiiServerPromise = this._startChii();

        this._proxy.on('proxyRes', (proxyRes: http.IncomingMessage, req: http.IncomingMessage, res: http.ServerResponse) => {
            let body: Buffer[] = [];
            
            // Check if it's HTML
            const isHtml = proxyRes.headers['content-type']?.includes('text/html');
            
            if (!isHtml) {
                // Pipe directly if not HTML
                res.writeHead(proxyRes.statusCode || 200, proxyRes.headers);
                proxyRes.pipe(res);
                return;
            }

            // For HTML, we need to intercept
            const originalEncoding = proxyRes.headers['content-encoding'];
            let stream: any = proxyRes;

            // Handle decompression if necessary
            if (originalEncoding === 'gzip') {
                stream = proxyRes.pipe(zlib.createGunzip());
            } else if (originalEncoding === 'deflate') {
                stream = proxyRes.pipe(zlib.createInflate());
            } else if (originalEncoding === 'br') {
                stream = proxyRes.pipe(zlib.createBrotliDecompress());
            }

            stream.on('data', (chunk: Buffer) => {
                body.push(chunk);
            });

            stream.on('end', () => {
                let html = Buffer.concat(body).toString();
                
                // INJECTION LOGIC
                console.log('[Proxy] Intercepting HTML response, length:', html.length);

                // Generate nonce for CSP-safe script injection
                const nonce = crypto.randomBytes(16).toString('base64');

                // 1. Inject Head CSP with nonce support
                // Allow unsafe-inline for styles (to not break existing page styles)
                // Use nonce for scripts (our injected scripts only)
                if (html.includes('<head>')) {
                    html = html.replace('<head>', `<head><meta content="default-src * 'unsafe-eval' ws: wss: data: blob:; script-src * 'nonce-${nonce}' 'unsafe-eval'; style-src * 'unsafe-inline';" http-equiv="Content-Security-Policy">`);
                }
                
                // 2. Inject Script + Styles at start of body with nonce
                const chiiScript = this._chiiPort 
                    ? `<script nonce="${nonce}" src="http://localhost:${this._chiiPort}/target.js"></script>` 
                    : '';

                const injection = `
                    ${chiiScript}
                    <script nonce="${nonce}" src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
                    <script nonce="${nonce}">
                        console.log('[Proxy] Injected Picker Script Loaded');
                        ${this._injectedScript}
                    </script>
                    <style>body { padding-top: 75px !important; margin-top: 0 !important; }</style>
                `;

                if (html.includes('<body')) {
                    console.log('[Proxy] Injecting into body tag with nonce-based CSP');
                    html = html.replace(/<body([^>]*)>/i, `<body$1>${injection}`);
                } else {
                    console.log('[Proxy] Prepending to HTML (no body tag found)');
                    html = injection + html;
                }

                // Remove existing Content-Length as size changed
                delete proxyRes.headers['content-length'];
                delete proxyRes.headers['content-encoding']; // We are sending back plain text (or could re-compress, but simpler not to)

                res.writeHead(proxyRes.statusCode || 200, proxyRes.headers);
                res.end(html);
            });
            
            stream.on('error', (err: any) => {
                console.error("Stream error", err);
                res.end();
            });
        });

        this._proxy.on('error', (err: Error, req: http.IncomingMessage, res: http.ServerResponse | any) => {
            console.error('Proxy error:', err);
            if (res && !res.headersSent) {
                res.writeHead(500, { 'Content-Type': 'text/plain' });
                res.end('Proxy Error: ' + err.message);
            }
        });
    }

    private async _startChii() {
        console.log('[ProxyServer] STATE: _startChii() invoked');
        if (this._chiiPort) {
            console.log(`[ProxyServer] INFO: Chii already running on port ${this._chiiPort}`);
            return;
        }
        
        try {
            console.log('[ProxyServer] ACTION: Starting Chii server...');
            
            // Chii.start() does NOT return the server instance with the port if we pass 0.
            // We need to create our own http server and pass it to Chii.
            const chiiServer = http.createServer();
            this._chiiServer = chiiServer; // Store reference for cleanup
            
            await new Promise<void>((resolve, reject) => {
                chiiServer.listen(0, '127.0.0.1', () => {
                    const addr = chiiServer.address();
                    if (addr && typeof addr !== 'string') {
                        this._chiiPort = addr.port;
                        console.log(`[ProxyServer] STEP: Chii base server listening on port ${this._chiiPort}`);
                        resolve();
                    } else {
                        reject(new Error('Failed to get Chii port'));
                    }
                });
                chiiServer.on('error', reject);
            });

            console.log(`[ProxyServer] ACTION: Initializing Chii logic on port ${this._chiiPort}`);
            // @ts-ignore
            await chii.start({ 
                server: chiiServer,
                domain: `localhost:${this._chiiPort}`
            });
            
            console.log(`[ProxyServer] LOG: Chii Server successfully fully initialized on port ${this._chiiPort}`);
            this._chiiReady = true;
            this._chiiStartupError = undefined;
        } catch (e: any) {
            console.error('[ProxyServer] CRITICAL ERROR: Failed to start Chii server:', e);
            if (e && e.stack) {
                console.error('[ProxyServer] STACK TRACE:', e.stack);
            }
            this._chiiReady = false;
            this._chiiStartupError = e;
            throw e; // Propagate error
        }
    }

    public async start(targetPort: number): Promise<number> {
        console.log(`[ProxyServer] TRIGGER: start() called targeting port ${targetPort}`);
        this._extensionHostPort = targetPort;

        // Ensure Chii is started and wait for it
        if (this._chiiServerPromise) {
            console.log('[ProxyServer] STEP: Waiting for _chiiServerPromise to resolve...');
            await this._chiiServerPromise;
        } else {
            console.log('[ProxyServer] STEP: No active _chiiServerPromise found. Starting manually...');
            this._chiiServerPromise = this._startChii();
            await this._chiiServerPromise;
        }
        
        console.log(`[ProxyServer] FINAL STATUS: Chii ready on port: ${this._chiiPort}`);

        return new Promise((resolve, reject) => {
            console.log(`[ProxyServer] ACTION: Starting HTTP server on dynamic port...`);
            this._server = http.createServer((req, res) => {
                this._proxy.web(req, res, {
                    target: `http://localhost:${this._extensionHostPort}`
                });
            });

            this._server.on('upgrade', (req, socket, head) => {
                this._proxy.ws(req, socket, head, {
                    target: `http://localhost:${this._extensionHostPort}`
                });
            });

            this._server.listen(0, '127.0.0.1', () => {
                const address = this._server?.address();
                if (address && typeof address !== 'string') {
                    this._port = address.port;
                    console.log(`[ProxyServer] SUCCESS: Proxy server listening on port ${this._port}`);
                    resolve(this._port);
                } else {
                    console.error('[ProxyServer] ERROR: Failed to get assigned port for proxy server');
                    reject(new Error('Failed to get proxy port'));
                }
            });

            this._server.on('error', (err) => {
                console.error('[ProxyServer] FATAL: HTTP Server failed to start:', err);
                reject(err);
            });
        });
    }

    public async getChiiUrl(retries = 3, delay = 1000): Promise<{ url?: string; error?: string }> {
        // Check if Chii failed to start
        if (this._chiiStartupError) {
            return { error: `DevTools server failed to start: ${this._chiiStartupError.message}` };
        }
        
        // Wait for Chii to be ready
        if (!this._chiiReady) {
            if (this._chiiServerPromise) {
                try {
                    await this._chiiServerPromise;
                } catch (e: any) {
                    return { error: `DevTools initialization failed: ${e.message}` };
                }
            }
        }
        
        if (!this._chiiPort) {
            return { error: 'DevTools server not initialized. Please load a localhost URL first.' };
        }

        // Retry logic for target discovery
        for (let attempt = 0; attempt < retries; attempt++) {
            try {
                console.log(`[ProxyServer] STEP: Fetching targets from http://127.0.0.1:${this._chiiPort}/targets (attempt ${attempt + 1}/${retries})`);
                
                const response = await new Promise<string>((resolve, reject) => {
                    const req = http.get({
                        hostname: '127.0.0.1',
                        port: this._chiiPort,
                        path: '/targets',
                        headers: { 
                            'accept': 'application/json',
                            'accept-encoding': 'identity' // PREVENT COMPRESSION
                        }
                    }, (res) => {
                        let data = '';
                        res.on('data', chunk => data += chunk);
                        res.on('end', () => resolve(data));
                    });
                    req.on('error', reject);
                    req.setTimeout(2000, () => {
                        req.destroy();
                        reject(new Error('Timeout fetching targets'));
                    });
                    req.end();
                });

                const parsed = JSON.parse(response);
                const targets = parsed.targets || [];
                console.log(`[ProxyServer] LOG: Found ${targets.length} Chii targets`);

                if (targets.length > 0) {
                    const targetId = targets[0].id;
                    const inspectUrl = `http://127.0.0.1:${this._chiiPort}/front_end/chii_app.html?ws=127.0.0.1:${this._chiiPort}/client/${targetId}?target=${targetId}`;
                    console.log(`[ProxyServer] SUCCESS: Generated inspect URL: ${inspectUrl}`);
                    return { url: inspectUrl };
                }
                
                // No targets found, retry if attempts remain
                if (attempt < retries - 1) {
                    console.log(`[ProxyServer] No targets found, retrying in ${delay}ms...`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            } catch (e: any) {
                console.error('[ProxyServer] ERROR: Failed to fetch Chii targets:', e);
                if (attempt === retries - 1) {
                    return { error: `Failed to connect to DevTools: ${e.message}` };
                }
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
        
        // Fallback: return base URL if no targets found after all retries
        const baseUrl = `http://127.0.0.1:${this._chiiPort}/`;
        console.log(`[ProxyServer] FALLBACK: No targets found after ${retries} attempts, returning base URL`);
        return { url: baseUrl };
    }

    public stop() {
        console.log('[ProxyServer] Stopping servers...');
        
        // Stop proxy server
        if (this._server) {
            this._server.close();
            this._server = undefined;
            console.log('[ProxyServer] Proxy server stopped');
        }
        
        // CRITICAL: Stop Chii server to prevent memory leaks
        if (this._chiiServer) {
            this._chiiServer.close(() => {
                console.log('[ProxyServer] Chii server stopped');
            });
            this._chiiServer = undefined;
            this._chiiPort = undefined;
            this._chiiReady = false;
        }
    }
}
