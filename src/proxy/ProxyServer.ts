import * as http from 'http';
import httpProxy from 'http-proxy';
import * as vscode from 'vscode';
import * as zlib from 'zlib';
import * as fs from 'fs';
import * as path from 'path';
import * as crypto from 'crypto';

// @ts-ignore
const chii = require('chii');

// Debug logging utility - only logs when enabled in settings
function debugLog(...args: any[]): void {
    const config = vscode.workspace.getConfiguration('visualBrowser');
    if (config.get<boolean>('enableDebugLogs', false)) {
        console.log(...args);
    }
}

export class ProxyServer {
    private _proxy: httpProxy;
    private _server: http.Server | undefined;
    private _extensionUri: vscode.Uri;
    private _port: number = 0;
    private _extensionHostPort: number = 0;
    private _injectedScriptContent: string = '';
    private _chiiPort: number | undefined;
    private _chiiServer: http.Server | undefined;
    private _chiiReady: boolean = false;
    private _chiiStartupError: Error | undefined;
    private _scriptServer: http.Server | undefined;
    private _scriptServerPort: number = 0;

    private _chiiServerPromise: Promise<void> | undefined;

    constructor(extensionUri: vscode.Uri) {
        this._extensionUri = extensionUri;
        
        // Load the injected script content once (now generated by webpack from TypeScript)
        try {
            const scriptPath = path.join(this._extensionUri.fsPath, 'media', 'injected-picker.js');
            this._injectedScriptContent = fs.readFileSync(scriptPath, 'utf8');
        } catch (e) {
            console.error('Failed to load injected-picker.js (ensure webview-ui has been built):', e);
        }
        
        // Start a simple HTTP server to serve the injected script
        this._startScriptServer();

        this._proxy = httpProxy.createProxyServer({
            ws: true,
            xfwd: true,
            secure: false,
            changeOrigin: false,
            selfHandleResponse: true // IMPORTANT: Allows us to modify response
        });

        // Pre-start Chii server and store the promise
        this._chiiServerPromise = this._startChii();

        this._proxy.on('proxyRes', (proxyRes: http.IncomingMessage, req: http.IncomingMessage, res: http.ServerResponse) => {
            debugLog(`[Proxy] INCOMING: ${req.method} ${req.url} (Status: ${proxyRes.statusCode})`);
            debugLog(`[Proxy] HEADERS:`, JSON.stringify(proxyRes.headers));

            let body: Buffer[] = [];
            
            // Check if it's HTML - ONLY use content-type, never guess
            const contentType = (proxyRes.headers['content-type'] || '').toLowerCase();
            
            // STRICT: Only inject into actual HTML responses
            // Do NOT guess based on URL - Vite serves JS from paths like /@vite/client
            const isHtml = contentType.includes('text/html') || 
                           contentType.includes('application/xhtml');
            
            debugLog(`[Proxy] DECISION: isHtml=${isHtml} (content-type: ${contentType}) for URL=${req.url}`);
            
            if (!isHtml) {
                // Pipe directly if not HTML
                res.writeHead(proxyRes.statusCode || 200, proxyRes.headers);
                proxyRes.pipe(res);
                return;
            }

            // For HTML, we need to intercept
            // STRIP CACHE HEADERS to ensure we always intercept
            delete proxyRes.headers['etag'];
            delete proxyRes.headers['last-modified'];
            proxyRes.headers['cache-control'] = 'no-cache, no-store, must-revalidate';
            proxyRes.headers['pragma'] = 'no-cache';
            proxyRes.headers['expires'] = '0';

            const originalEncoding = proxyRes.headers['content-encoding'];
            let stream: any = proxyRes;

            // Handle decompression if necessary
            if (originalEncoding === 'gzip') {
                stream = proxyRes.pipe(zlib.createGunzip());
            } else if (originalEncoding === 'deflate') {
                stream = proxyRes.pipe(zlib.createInflate());
            } else if (originalEncoding === 'br') {
                stream = proxyRes.pipe(zlib.createBrotliDecompress());
            }

            stream.on('data', (chunk: Buffer) => {
                body.push(chunk);
            });

            stream.on('end', () => {
                let html = Buffer.concat(body).toString();
                
                debugLog('[Proxy] Intercepting HTML response, length:', html.length);
                debugLog('[Proxy] Request URL:', req.url);

                // IMPORTANT: Strip any existing CSP that might block our scripts
                const cspMetaMatch = html.match(/<meta[^>]*http-equiv=["']Content-Security-Policy["'][^>]*>/gi);
                if (cspMetaMatch) {
                    debugLog('[Proxy] Found CSP meta tags to strip:', cspMetaMatch.length);
                }
                html = html.replace(/<meta[^>]*http-equiv=["']Content-Security-Policy["'][^>]*>/gi, '');
                
                // Also strip CSP from Content-Security-Policy header
                if (proxyRes.headers['content-security-policy']) {
                    debugLog('[Proxy] Stripping CSP header:', proxyRes.headers['content-security-policy']);
                }
                delete proxyRes.headers['content-security-policy'];
                delete proxyRes.headers['content-security-policy-report-only'];
                
                debugLog('[Proxy] Script server port:', this._scriptServerPort);
                debugLog('[Proxy] Chii port:', this._chiiPort);
                
                // 2. Inject Script + Styles at start of body
                // Use external script tags to avoid template literal escaping issues
                const chiiScript = this._chiiPort 
                    ? `<script src="http://localhost:${this._chiiPort}/target.js"></script>` 
                    : '';

                // Load injected script from our local script server instead of inlining
                const pickerScript = this._scriptServerPort
                    ? `<script src="http://127.0.0.1:${this._scriptServerPort}/injected-picker.js"></script>`
                    : '';

                const injection = `
                    ${chiiScript}
                    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
                    ${pickerScript}
                    <style>body { padding-top: 75px !important; margin-top: 0 !important; }</style>
                `;

                // Try multiple injection points for compatibility with different frameworks
                if (html.includes('<body')) {
                    debugLog('[Proxy] Injecting into body tag');
                    html = html.replace(/<body([^>]*)>/i, `<body$1>${injection}`);
                } else if (html.includes('<head>')) {
                    debugLog('[Proxy] No body tag found, injecting after head');
                    html = html.replace('</head>', `</head>${injection}`);
                } else {
                    debugLog('[Proxy] Prepending to HTML (no body or head tag found)');
                    html = injection + html;
                }
                
                debugLog('[Proxy] Final HTML length after injection:', html.length);

                // Remove existing Content-Length as size changed
                delete proxyRes.headers['content-length'];
                delete proxyRes.headers['content-encoding']; // We are sending back plain text (or could re-compress, but simpler not to)

                res.writeHead(proxyRes.statusCode || 200, proxyRes.headers);
                res.end(html);
            });
            
            stream.on('error', (err: any) => {
                console.error("Stream error", err);
                res.end();
            });
        });

        this._proxy.on('error', (err: Error, req: http.IncomingMessage, res: http.ServerResponse | any) => {
            console.error('Proxy error:', err);
            if (res && !res.headersSent) {
                res.writeHead(500, { 'Content-Type': 'text/plain' });
                res.end('Proxy Error: ' + err.message);
            }
        });
    }

    private _startScriptServer(): void {
        this._scriptServer = http.createServer((req, res) => {
            // Add CORS headers to allow loading from any origin
            res.setHeader('Access-Control-Allow-Origin', '*');
            res.setHeader('Access-Control-Allow-Methods', 'GET');
            res.setHeader('Content-Type', 'application/javascript');
            res.setHeader('Cache-Control', 'no-cache');
            
            if (req.url === '/injected-picker.js') {
                res.writeHead(200);
                res.end(this._injectedScriptContent);
            } else {
                res.writeHead(404);
                res.end('Not found');
            }
        });
        
        this._scriptServer.listen(0, '127.0.0.1', () => {
            const addr = this._scriptServer?.address();
            if (addr && typeof addr !== 'string') {
                this._scriptServerPort = addr.port;
                debugLog(`[ProxyServer] Script server listening on port ${this._scriptServerPort}`);
            }
        });
    }

    private async _startChii() {
        // console.log('[ProxyServer] STATE: _startChii() invoked');
        if (this._chiiPort) {
            // console.log(`[ProxyServer] INFO: Chii already running on port ${this._chiiPort}`);
            return;
        }
        
        try {
            // console.log('[ProxyServer] ACTION: Starting Chii server...');
            
            // Chii.start() does NOT return the server instance with the port if we pass 0.
            // We need to create our own http server and pass it to Chii.
            const chiiServer = http.createServer();
            this._chiiServer = chiiServer; // Store reference for cleanup
            
            await new Promise<void>((resolve, reject) => {
                chiiServer.listen(0, '127.0.0.1', () => {
                    const addr = chiiServer.address();
                    if (addr && typeof addr !== 'string') {
                        this._chiiPort = addr.port;
                        // console.log(`[ProxyServer] STEP: Chii base server listening on port ${this._chiiPort}`);
                        resolve();
                    } else {
                        reject(new Error('Failed to get Chii port'));
                    }
                });
                chiiServer.on('error', reject);
            });

            debugLog(`[ProxyServer] ACTION: Initializing Chii logic on port ${this._chiiPort}`);
            // @ts-ignore
            await chii.start({ 
                server: chiiServer,
                domain: `localhost:${this._chiiPort}`
            });
            
            // console.log(`[ProxyServer] LOG: Chii Server successfully fully initialized on port ${this._chiiPort}`);
            this._chiiReady = true;
            this._chiiStartupError = undefined;
        } catch (e: any) {
            console.error('[ProxyServer] CRITICAL ERROR: Failed to start Chii server:', e);
            if (e && e.stack) {
                console.error('[ProxyServer] STACK TRACE:', e.stack);
            }
            this._chiiReady = false;
            this._chiiStartupError = e;
            throw e; // Propagate error
        }
    }

    public async start(targetPort: number): Promise<number> {
        // console.log(`[ProxyServer] TRIGGER: start() called targeting port ${targetPort}`);
        this._extensionHostPort = targetPort;

        // Ensure Chii is started and wait for it
        if (this._chiiServerPromise) {
            // console.log('[ProxyServer] STEP: Waiting for _chiiServerPromise to resolve...');
            await this._chiiServerPromise;
        } else {
            // console.log('[ProxyServer] STEP: No active _chiiServerPromise found. Starting manually...');
            this._chiiServerPromise = this._startChii();
            await this._chiiServerPromise;
        }
        
        // console.log(`[ProxyServer] FINAL STATUS: Chii ready on port: ${this._chiiPort}`);

        return new Promise((resolve, reject) => {
            // console.log(`[ProxyServer] ACTION: Starting HTTP server on dynamic port...`);
            this._server = http.createServer((req, res) => {
                this._proxy.web(req, res, {
                    target: `http://localhost:${this._extensionHostPort}`,
                    headers: {
                        'accept-encoding': 'identity' // Request uncompressed content from Vite
                    }
                });
            });

            this._server.on('upgrade', (req, socket, head) => {
                this._proxy.ws(req, socket, head, {
                    target: `http://localhost:${this._extensionHostPort}`,
                    ws: true
                });
            });

            this._server.listen(0, '127.0.0.1', () => {
                const address = this._server?.address();
                if (address && typeof address !== 'string') {
                    this._port = address.port;
                    // console.log(`[ProxyServer] SUCCESS: Proxy server listening on port ${this._port}`);
                    resolve(this._port);
                } else {
                    console.error('[ProxyServer] ERROR: Failed to get assigned port for proxy server');
                    reject(new Error('Failed to get proxy port'));
                }
            });

            this._server.on('error', (err) => {
                console.error('[ProxyServer] FATAL: HTTP Server failed to start:', err);
                reject(err);
            });
        });
    }

    public async getChiiUrl(retries = 3, delay = 1000): Promise<{ url?: string; error?: string }> {
        // Check if Chii failed to start
        if (this._chiiStartupError) {
            return { error: `DevTools server failed to start: ${this._chiiStartupError.message}` };
        }
        
        // Wait for Chii to be ready
        if (!this._chiiReady) {
            if (this._chiiServerPromise) {
                try {
                    await this._chiiServerPromise;
                } catch (e: any) {
                    return { error: `DevTools initialization failed: ${e.message}` };
                }
            }
        }
        
        if (!this._chiiPort) {
            return { error: 'DevTools server not initialized. Please load a localhost URL first.' };
        }

        // Retry logic for target discovery
        for (let attempt = 0; attempt < retries; attempt++) {
            try {
                // console.log(`[ProxyServer] STEP: Fetching targets from http://127.0.0.1:${this._chiiPort}/targets (attempt ${attempt + 1}/${retries})`);
                
                const response = await new Promise<string>((resolve, reject) => {
                    const req = http.get({
                        hostname: '127.0.0.1',
                        port: this._chiiPort,
                        path: '/targets',
                        headers: { 
                            'accept': 'application/json',
                            'accept-encoding': 'identity' // PREVENT COMPRESSION
                        }
                    }, (res) => {
                        let data = '';
                        res.on('data', chunk => data += chunk);
                        res.on('end', () => resolve(data));
                    });
                    req.on('error', reject);
                    req.setTimeout(2000, () => {
                        req.destroy();
                        reject(new Error('Timeout fetching targets'));
                    });
                    req.end();
                });

                const parsed = JSON.parse(response);
                const targets = parsed.targets || [];
                // console.log(`[ProxyServer] LOG: Found ${targets.length} Chii targets`);

                if (targets.length > 0) {
                    const targetId = targets[0].id;
                    const inspectUrl = `http://127.0.0.1:${this._chiiPort}/front_end/chii_app.html?ws=127.0.0.1:${this._chiiPort}/client/${targetId}?target=${targetId}`;
                    // console.log(`[ProxyServer] SUCCESS: Generated inspect URL: ${inspectUrl}`);
                    return { url: inspectUrl };
                }
                
                // No targets found, retry if attempts remain
                if (attempt < retries - 1) {
                    // console.log(`[ProxyServer] No targets found, retrying in ${delay}ms...`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            } catch (e: any) {
                console.error('[ProxyServer] ERROR: Failed to fetch Chii targets:', e);
                if (attempt === retries - 1) {
                    return { error: `Failed to connect to DevTools: ${e.message}` };
                }
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
        
        // Fallback: return base URL if no targets found after all retries
        const baseUrl = `http://127.0.0.1:${this._chiiPort}/`;
        // console.log(`[ProxyServer] FALLBACK: No targets found after ${retries} attempts, returning base URL`);
        return { url: baseUrl };
    }

    public stop() {
        // console.log('[ProxyServer] Stopping servers...');
        
        // Stop proxy server
        if (this._server) {
            this._server.close();
            this._server = undefined;
            // console.log('[ProxyServer] Proxy server stopped');
        }
        
        // CRITICAL: Stop Chii server to prevent memory leaks
        if (this._chiiServer) {
            this._chiiServer.close(() => {
                // console.log('[ProxyServer] Chii server stopped');
            });
            this._chiiServer = undefined;
            this._chiiPort = undefined;
            this._chiiReady = false;
        }
        
        // Stop script server
        if (this._scriptServer) {
            this._scriptServer.close();
            this._scriptServer = undefined;
            this._scriptServerPort = 0;
        }
    }
}
