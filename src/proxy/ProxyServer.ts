import * as http from 'http';
import httpProxy from 'http-proxy';
import * as vscode from 'vscode';
import * as zlib from 'zlib';
import * as fs from 'fs';
import * as path from 'path';
import * as crypto from 'crypto';
import { StorageManager } from '../storage/StorageManager';

// @ts-ignore
const chii = require('chii');

// Debug logging utility - only logs when enabled in settings
function debugLog(...args: any[]): void {
    const config = vscode.workspace.getConfiguration('visualBrowser');
    if (config.get<boolean>('enableDebugLogs', false)) {
        console.log(...args);
    }
}

export class ProxyServer {
    private _proxy: httpProxy;
    private _server: http.Server | undefined;
    private _extensionUri: vscode.Uri;
    private _port: number = 0;
    private _extensionHostPort: number = 0;
    private _injectedScriptContent: string = '';
    private _chiiPort: number | undefined;
    private _chiiServer: http.Server | undefined;
    private _chiiReady: boolean = false;
    private _chiiStartupError: Error | undefined;
    private _scriptServer: http.Server | undefined;
    private _scriptServerPort: number = 0;
    private _storageManager: StorageManager | null = null;

    private _chiiServerPromise: Promise<void> | undefined;

    constructor(extensionUri: vscode.Uri) {
        this._extensionUri = extensionUri;
        
        // Load the injected script content once (now generated by webpack from TypeScript)
        try {
            const scriptPath = path.join(this._extensionUri.fsPath, 'media', 'injected-picker.js');
            this._injectedScriptContent = fs.readFileSync(scriptPath, 'utf8');
        } catch (e) {
            console.error('Failed to load injected-picker.js (ensure webview-ui has been built):', e);
        }
        
        // Start a simple HTTP server to serve the injected script
        this._startScriptServer();

        this._proxy = httpProxy.createProxyServer({
            ws: true,
            xfwd: true,
            secure: false,
            changeOrigin: false,
            selfHandleResponse: true // IMPORTANT: Allows us to modify response
        });

        // Pre-start Chii server and store the promise
        this._chiiServerPromise = this._startChii();

        this._proxy.on('proxyRes', (proxyRes: http.IncomingMessage, req: http.IncomingMessage, res: http.ServerResponse) => {
            debugLog(`[Proxy] INCOMING: ${req.method} ${req.url} (Status: ${proxyRes.statusCode})`);
            debugLog(`[Proxy] HEADERS:`, JSON.stringify(proxyRes.headers));

            let body: Buffer[] = [];
            
            // Check if it's HTML - ONLY use content-type, never guess
            const contentType = (proxyRes.headers['content-type'] || '').toLowerCase();
            
            // STRICT: Only inject into actual HTML responses
            // Do NOT guess based on URL - Vite serves JS from paths like /@vite/client
            const isHtml = contentType.includes('text/html') || 
                           contentType.includes('application/xhtml');
            
            debugLog(`[Proxy] DECISION: isHtml=${isHtml} (content-type: ${contentType}) for URL=${req.url}`);
            
            if (!isHtml) {
                // Pipe directly if not HTML
                res.writeHead(proxyRes.statusCode || 200, proxyRes.headers);
                proxyRes.pipe(res);
                return;
            }

            // For HTML, we need to intercept
            // STRIP CACHE HEADERS to ensure we always intercept
            delete proxyRes.headers['etag'];
            delete proxyRes.headers['last-modified'];
            proxyRes.headers['cache-control'] = 'no-cache, no-store, must-revalidate';
            proxyRes.headers['pragma'] = 'no-cache';
            proxyRes.headers['expires'] = '0';

            const originalEncoding = proxyRes.headers['content-encoding'];
            let stream: any = proxyRes;

            // Handle decompression if necessary
            if (originalEncoding === 'gzip') {
                stream = proxyRes.pipe(zlib.createGunzip());
            } else if (originalEncoding === 'deflate') {
                stream = proxyRes.pipe(zlib.createInflate());
            } else if (originalEncoding === 'br') {
                stream = proxyRes.pipe(zlib.createBrotliDecompress());
            }

            stream.on('data', (chunk: Buffer) => {
                body.push(chunk);
            });

            stream.on('end', () => {
                let html = Buffer.concat(body).toString();
                
                debugLog('[Proxy] Intercepting HTML response, length:', html.length);
                debugLog('[Proxy] Request URL:', req.url);

                // IMPORTANT: Strip any existing CSP that might block our scripts
                const cspMetaMatch = html.match(/<meta[^>]*http-equiv=["']Content-Security-Policy["'][^>]*>/gi);
                if (cspMetaMatch) {
                    debugLog('[Proxy] Found CSP meta tags to strip:', cspMetaMatch.length);
                }
                html = html.replace(/<meta[^>]*http-equiv=["']Content-Security-Policy["'][^>]*>/gi, '');
                
                // Also strip CSP from Content-Security-Policy header
                if (proxyRes.headers['content-security-policy']) {
                    debugLog('[Proxy] Stripping CSP header:', proxyRes.headers['content-security-policy']);
                }
                delete proxyRes.headers['content-security-policy'];
                delete proxyRes.headers['content-security-policy-report-only'];
                
                debugLog('[Proxy] Script server port:', this._scriptServerPort);
                debugLog('[Proxy] Chii port:', this._chiiPort);
                
                // 2. Inject Script + Styles at start of body
                // Use external script tags to avoid template literal escaping issues
                const chiiScript = this._chiiPort 
                    ? `<script src="http://localhost:${this._chiiPort}/target.js"></script>` 
                    : '';

                // Load injected script from our local script server instead of inlining
                const pickerScript = this._scriptServerPort
                    ? `<script src="http://127.0.0.1:${this._scriptServerPort}/injected-picker.js"></script>`
                    : '';

                // Generate localStorage/sessionStorage polyfill injection
                const storageInjection = this._generateStorageInjection();

                const injection = `
                    ${chiiScript}
                    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
                    ${pickerScript}
                    ${storageInjection}
                    <style>body { padding-top: 75px !important; margin-top: 0 !important; }</style>
                `;

                // Try multiple injection points for compatibility with different frameworks
                if (html.includes('<body')) {
                    debugLog('[Proxy] Injecting into body tag');
                    html = html.replace(/<body([^>]*)>/i, `<body$1>${injection}`);
                } else if (html.includes('<head>')) {
                    debugLog('[Proxy] No body tag found, injecting after head');
                    html = html.replace('</head>', `</head>${injection}`);
                } else {
                    debugLog('[Proxy] Prepending to HTML (no body or head tag found)');
                    html = injection + html;
                }
                
                debugLog('[Proxy] Final HTML length after injection:', html.length);

                // Remove existing Content-Length as size changed
                delete proxyRes.headers['content-length'];
                delete proxyRes.headers['content-encoding']; // We are sending back plain text (or could re-compress, but simpler not to)

                res.writeHead(proxyRes.statusCode || 200, proxyRes.headers);
                res.end(html);
            });
            
            stream.on('error', (err: any) => {
                console.error("Stream error", err);
                res.end();
            });
        });

        this._proxy.on('error', (err: Error, req: http.IncomingMessage, res: http.ServerResponse | any) => {
            console.error('Proxy error:', err);
            if (res && !res.headersSent) {
                res.writeHead(500, { 'Content-Type': 'text/plain' });
                res.end('Proxy Error: ' + err.message);
            }
        });
    }

    private _startScriptServer(): void {
        this._scriptServer = http.createServer((req, res) => {
            // Add CORS headers to allow loading from any origin
            res.setHeader('Access-Control-Allow-Origin', '*');
            res.setHeader('Access-Control-Allow-Methods', 'GET');
            res.setHeader('Content-Type', 'application/javascript');
            res.setHeader('Cache-Control', 'no-cache');
            
            if (req.url === '/injected-picker.js') {
                res.writeHead(200);
                res.end(this._injectedScriptContent);
            } else {
                res.writeHead(404);
                res.end('Not found');
            }
        });
        
        this._scriptServer.listen(0, '127.0.0.1', () => {
            const addr = this._scriptServer?.address();
            if (addr && typeof addr !== 'string') {
                this._scriptServerPort = addr.port;
                debugLog(`[ProxyServer] Script server listening on port ${this._scriptServerPort}`);
            }
        });
    }

    /**
     * Set the storage manager for cookie and storage handling
     */
    public setStorageManager(storageManager: StorageManager): void {
        this._storageManager = storageManager;
    }

    /**
     * Generate JavaScript for localStorage/sessionStorage with VS Code persistence
     */
    private _generateStorageInjection(): string {
        return `
<script>
(function() {
    // ===== Optimized Storage Implementation =====
    
    // In-memory storage
    var _localStorageData = {};
    var _sessionStorageData = {};
    var _initialized = false;

    // ===== Storage Event Dispatcher =====
    function dispatchStorageEvent(key, newValue, oldValue, url) {
        try {
            var event = new StorageEvent('storage', {
                key: key,
                newValue: newValue,
                oldValue: oldValue,
                url: url || window.location.href
            });
            window.dispatchEvent(event);
        } catch (e) {
            // Ignore - most code doesn't rely on storage events
        }
    }

    // ===== LocalStorage Proxy =====
    var localStorage = {
        getItem: function(key) {
            return _localStorageData.hasOwnProperty(key) ? _localStorageData[key] : null;
        },
        setItem: function(key, value) {
            var oldValue = _localStorageData.hasOwnProperty(key) ? _localStorageData[key] : null;
            _localStorageData[key] = String(value);
            dispatchStorageEvent(key, value, oldValue);
            // Notify VS Code extension (async, non-blocking)
            try { window.parent.postMessage({ command: 'storageUpdate', type: 'localStorage', action: 'set', key: key, value: value }, '*'); } catch(e) {}
        },
        removeItem: function(key) {
            var oldValue = _localStorageData.hasOwnProperty(key) ? _localStorageData[key] : null;
            delete _localStorageData[key];
            dispatchStorageEvent(key, null, oldValue);
            try { window.parent.postMessage({ command: 'storageUpdate', type: 'localStorage', action: 'remove', key: key }, '*'); } catch(e) {}
        },
        clear: function() {
            _localStorageData = {};
            try { window.parent.postMessage({ command: 'storageUpdate', type: 'localStorage', action: 'clear' }, '*'); } catch(e) {}
        },
        key: function(index) {
            var keys = Object.keys(_localStorageData);
            return keys[index] || null;
        },
        get length() {
            return Object.keys(_localStorageData).length;
        }
    };

    Object.defineProperty(window, 'localStorage', { get: function() { return localStorage; }, set: function() {}, configurable: false });

    // ===== SessionStorage Proxy =====
    var sessionStorage = {
        getItem: function(key) {
            return _sessionStorageData.hasOwnProperty(key) ? _sessionStorageData[key] : null;
        },
        setItem: function(key, value) {
            var oldValue = _sessionStorageData.hasOwnProperty(key) ? _sessionStorageData[key] : null;
            _sessionStorageData[key] = String(value);
            dispatchStorageEvent(key, value, oldValue);
            try { window.parent.postMessage({ command: 'storageUpdate', type: 'sessionStorage', action: 'set', key: key, value: value }, '*'); } catch(e) {}
        },
        removeItem: function(key) {
            var oldValue = _sessionStorageData.hasOwnProperty(key) ? _sessionStorageData[key] : null;
            delete _sessionStorageData[key];
            dispatchStorageEvent(key, null, oldValue);
            try { window.parent.postMessage({ command: 'storageUpdate', type: 'sessionStorage', action: 'remove', key: key }, '*'); } catch(e) {}
        },
        clear: function() {
            _sessionStorageData = {};
            try { window.parent.postMessage({ command: 'storageUpdate', type: 'sessionStorage', action: 'clear' }, '*'); } catch(e) {}
        },
        key: function(index) {
            var keys = Object.keys(_sessionStorageData);
            return keys[index] || null;
        },
        get length() {
            return Object.keys(_sessionStorageData).length;
        }
    };

    Object.defineProperty(window, 'sessionStorage', { get: function() { return sessionStorage; }, set: function() {}, configurable: false });

    // ===== IndexedDB Polyfill =====
    var _indexedDBData = {};
    
    var indexedDB = {
        open: function(name, version) {
            var request = {
                result: null,
                onsuccess: null,
                onerror: null,
                readyState: 'pending'
            };
            
            // Load from localStorage
            try {
                var stored = localStorage.getItem('__indexeddb_' + name);
                if (stored) {
                    _indexedDBData[name] = JSON.parse(stored);
                } else {
                    _indexedDBData[name] = { stores: {}, version: version || 1 };
                }
            } catch (e) {
                _indexedDBData[name] = { stores: {}, version: version || 1 };
            }
            
            var db = {
                name: name,
                version: version || 1,
                objectStoreNames: Object.keys(_indexedDBData[name].stores),
                close: function() {},
                transaction: function(storeNames, mode) {
                    return {
                        objectStore: function(storeName) {
                            var store = _indexedDBData[name].stores[storeName];
                            return {
                                get: function(key) {
                                    return { result: store ? store[key] : undefined, onsuccess: null, onerror: null };
                                },
                                put: function(value, key) {
                                    if (!store) { _indexedDBData[name].stores[storeName] = {}; }
                                    _indexedDBData[name].stores[storeName][key || value.key] = value;
                                    localStorage.setItem('__indexeddb_' + name, JSON.stringify(_indexedDBData[name]));
                                    return { result: undefined, onsuccess: null, onerror: null };
                                },
                                delete: function(key) {
                                    if (store && store[key]) { delete store[key]; localStorage.setItem('__indexeddb_' + name, JSON.stringify(_indexedDBData[name])); }
                                    return { result: undefined, onsuccess: null, onerror: null };
                                },
                                clear: function() {
                                    if (store) { _indexedDBData[name].stores[storeName] = {}; localStorage.setItem('__indexeddb_' + name, JSON.stringify(_indexedDBData[name])); }
                                    return { result: undefined, onsuccess: null, onerror: null };
                                },
                                getAll: function() {
                                    return { result: store ? Object.values(store) : [], onsuccess: null, onerror: null };
                                },
                                getAllKeys: function() {
                                    return { result: store ? Object.keys(store) : [], onsuccess: null, onerror: null };
                                },
                                createIndex: function() { return this; },
                                index: function() { return this; }
                            };
                        },
                        abort: function() {},
                        commit: function() {},
                        oncomplete: null,
                        onabort: null,
                        onerror: null
                    };
                }
            };
            
            request.result = db;
            request.readyState = 'done';
            
            setTimeout(function() {
                if (request.onsuccess) { request.onsuccess({ target: request }); }
            }, 0);
            
            return request;
        },
        deleteDatabase: function(name) {
            localStorage.removeItem('__indexeddb_' + name);
            delete _indexedDBData[name];
            return { result: undefined, onsuccess: null, onerror: null };
        },
        cmp: function(a, b) {
            if (a < b) return -1;
            if (a > b) return 1;
            return 0;
        }
    };
    
    Object.defineProperty(window, 'indexedDB', { get: function() { return indexedDB; }, set: function() {}, configurable: false });

    // ===== Request storage data from parent on load =====
    // Fire once and forget - parent will respond
    try {
        window.parent.postMessage({ command: 'storageRequest', type: 'localStorage' }, '*');
        window.parent.postMessage({ command: 'storageRequest', type: 'sessionStorage' }, '*');
    } catch(e) {}

    // Listen for storage data from parent
    window.addEventListener('message', function(event) {
        try {
            if (event.data && event.data.command === 'storageData') {
                if (event.data.storageType === 'localStorage' && event.data.data) {
                    _localStorageData = event.data.data;
                    _initialized = true;
                } else if (event.data.storageType === 'sessionStorage' && event.data.data) {
                    _sessionStorageData = event.data.data;
                }
            }
        } catch(e) {}
    });

    console.log('[Storage] Optimized storage initialized');
})();
</script>
        `;
    }

    /**
     * Handle proxy requests with cookie support
     */
    private async _handleProxyRequest(req: http.IncomingMessage, res: http.ServerResponse): Promise<void> {
        // Get cookies from storage manager if available
        let cookieHeader = '';
        if (this._storageManager && req.url) {
            try {
                const url = new URL(req.url, `http://localhost:${this._extensionHostPort}`).href;
                cookieHeader = await this._storageManager.getCookieHeader(url);
            } catch (e) {
                // Ignore URL parsing errors
            }
        }

        // Add cookie header to the request if we have one
        const headers: { [key: string]: string } = {};
        
        // Copy existing headers, converting arrays to strings
        for (const [key, value] of Object.entries(req.headers)) {
            if (value) {
                headers[key] = Array.isArray(value) ? value[0] : value;
            }
        }
        headers['accept-encoding'] = 'identity';
        
        if (cookieHeader) {
            headers['cookie'] = cookieHeader;
        }

        // @ts-ignore - http-proxy expects specific header format
        this._proxy.web(req, res, {
            target: `http://localhost:${this._extensionHostPort}`,
            headers: headers
        });
    }

    private async _startChii() {
        // console.log('[ProxyServer] STATE: _startChii() invoked');
        if (this._chiiPort) {
            // console.log(`[ProxyServer] INFO: Chii already running on port ${this._chiiPort}`);
            return;
        }
        
        try {
            // console.log('[ProxyServer] ACTION: Starting Chii server...');
            
            // Chii.start() does NOT return the server instance with the port if we pass 0.
            // We need to create our own http server and pass it to Chii.
            const chiiServer = http.createServer();
            this._chiiServer = chiiServer; // Store reference for cleanup
            
            await new Promise<void>((resolve, reject) => {
                chiiServer.listen(0, '127.0.0.1', () => {
                    const addr = chiiServer.address();
                    if (addr && typeof addr !== 'string') {
                        this._chiiPort = addr.port;
                        // console.log(`[ProxyServer] STEP: Chii base server listening on port ${this._chiiPort}`);
                        resolve();
                    } else {
                        reject(new Error('Failed to get Chii port'));
                    }
                });
                chiiServer.on('error', reject);
            });

            debugLog(`[ProxyServer] ACTION: Initializing Chii logic on port ${this._chiiPort}`);
            // @ts-ignore
            await chii.start({ 
                server: chiiServer,
                domain: `localhost:${this._chiiPort}`
            });
            
            // console.log(`[ProxyServer] LOG: Chii Server successfully fully initialized on port ${this._chiiPort}`);
            this._chiiReady = true;
            this._chiiStartupError = undefined;
        } catch (e: any) {
            console.error('[ProxyServer] CRITICAL ERROR: Failed to start Chii server:', e);
            if (e && e.stack) {
                console.error('[ProxyServer] STACK TRACE:', e.stack);
            }
            this._chiiReady = false;
            this._chiiStartupError = e;
            throw e; // Propagate error
        }
    }

    public async start(targetPort: number): Promise<number> {
        // console.log(`[ProxyServer] TRIGGER: start() called targeting port ${targetPort}`);
        this._extensionHostPort = targetPort;

        // Ensure Chii is started and wait for it
        if (this._chiiServerPromise) {
            // console.log('[ProxyServer] STEP: Waiting for _chiiServerPromise to resolve...');
            await this._chiiServerPromise;
        } else {
            // console.log('[ProxyServer] STEP: No active _chiiServerPromise found. Starting manually...');
            this._chiiServerPromise = this._startChii();
            await this._chiiServerPromise;
        }
        
        // console.log(`[ProxyServer] FINAL STATUS: Chii ready on port: ${this._chiiPort}`);

        return new Promise((resolve, reject) => {
            // console.log(`[ProxyServer] ACTION: Starting HTTP server on dynamic port...`);
            this._server = http.createServer((req, res) => {
                // Add cookie handling for proxy requests
                this._handleProxyRequest(req, res);
            });

            this._server.on('upgrade', (req, socket, head) => {
                this._proxy.ws(req, socket, head, {
                    target: `http://localhost:${this._extensionHostPort}`,
                    ws: true
                });
            });

            this._server.listen(0, '127.0.0.1', () => {
                const address = this._server?.address();
                if (address && typeof address !== 'string') {
                    this._port = address.port;
                    // console.log(`[ProxyServer] SUCCESS: Proxy server listening on port ${this._port}`);
                    resolve(this._port);
                } else {
                    console.error('[ProxyServer] ERROR: Failed to get assigned port for proxy server');
                    reject(new Error('Failed to get proxy port'));
                }
            });

            this._server.on('error', (err) => {
                console.error('[ProxyServer] FATAL: HTTP Server failed to start:', err);
                reject(err);
            });
        });
    }

    public async getChiiUrl(retries = 3, delay = 1000): Promise<{ url?: string; error?: string }> {
        // Check if Chii failed to start
        if (this._chiiStartupError) {
            return { error: `DevTools server failed to start: ${this._chiiStartupError.message}` };
        }
        
        // Wait for Chii to be ready
        if (!this._chiiReady) {
            if (this._chiiServerPromise) {
                try {
                    await this._chiiServerPromise;
                } catch (e: any) {
                    return { error: `DevTools initialization failed: ${e.message}` };
                }
            }
        }
        
        if (!this._chiiPort) {
            return { error: 'DevTools server not initialized. Please load a localhost URL first.' };
        }

        // Retry logic for target discovery
        for (let attempt = 0; attempt < retries; attempt++) {
            try {
                // console.log(`[ProxyServer] STEP: Fetching targets from http://127.0.0.1:${this._chiiPort}/targets (attempt ${attempt + 1}/${retries})`);
                
                const response = await new Promise<string>((resolve, reject) => {
                    const req = http.get({
                        hostname: '127.0.0.1',
                        port: this._chiiPort,
                        path: '/targets',
                        headers: { 
                            'accept': 'application/json',
                            'accept-encoding': 'identity' // PREVENT COMPRESSION
                        }
                    }, (res) => {
                        let data = '';
                        res.on('data', chunk => data += chunk);
                        res.on('end', () => resolve(data));
                    });
                    req.on('error', reject);
                    req.setTimeout(2000, () => {
                        req.destroy();
                        reject(new Error('Timeout fetching targets'));
                    });
                    req.end();
                });

                const parsed = JSON.parse(response);
                const targets = parsed.targets || [];
                // console.log(`[ProxyServer] LOG: Found ${targets.length} Chii targets`);

                if (targets.length > 0) {
                    const targetId = targets[0].id;
                    const inspectUrl = `http://127.0.0.1:${this._chiiPort}/front_end/chii_app.html?ws=127.0.0.1:${this._chiiPort}/client/${targetId}?target=${targetId}`;
                    // console.log(`[ProxyServer] SUCCESS: Generated inspect URL: ${inspectUrl}`);
                    return { url: inspectUrl };
                }
                
                // No targets found, retry if attempts remain
                if (attempt < retries - 1) {
                    // console.log(`[ProxyServer] No targets found, retrying in ${delay}ms...`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            } catch (e: any) {
                console.error('[ProxyServer] ERROR: Failed to fetch Chii targets:', e);
                if (attempt === retries - 1) {
                    return { error: `Failed to connect to DevTools: ${e.message}` };
                }
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
        
        // Fallback: return base URL if no targets found after all retries
        const baseUrl = `http://127.0.0.1:${this._chiiPort}/`;
        // console.log(`[ProxyServer] FALLBACK: No targets found after ${retries} attempts, returning base URL`);
        return { url: baseUrl };
    }

    public stop() {
        // console.log('[ProxyServer] Stopping servers...');
        
        // Stop proxy server
        if (this._server) {
            this._server.close();
            this._server = undefined;
            // console.log('[ProxyServer] Proxy server stopped');
        }
        
        // CRITICAL: Stop Chii server to prevent memory leaks
        if (this._chiiServer) {
            this._chiiServer.close(() => {
                // console.log('[ProxyServer] Chii server stopped');
            });
            this._chiiServer = undefined;
            this._chiiPort = undefined;
            this._chiiReady = false;
        }
        
        // Stop script server
        if (this._scriptServer) {
            this._scriptServer.close();
            this._scriptServer = undefined;
            this._scriptServerPort = 0;
        }
    }
}
